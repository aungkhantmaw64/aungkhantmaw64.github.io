+++
date = '2025-10-12T16:41:18+07:00'
draft = false
title = 'Roll Your Own (RYO) Embedded Linux Distro'
thumbnail = "images/blue-penguin.jpg"
tags = ["u-boot", "busybox", "linux"]
categories = ["Embedded Linux"]
+++

_Having Fun With U-Boot, Linux, & Busybox_

## <!--more-->

## Background

Building a custom Linux image for single-board computer platforms without using any build systems is a tremendous learning experience. You work on toolchain installation and customization, bootloader and kernel configuration, and finally, the root file system. This process helps you understand what happens at each stage of the embedded system development life cycle.

Why would we build a custom image in the first place?
Why not just use off-the-shelf operating systems provided by the board vendors, such as [Raspberry Pi OS](https://www.raspberrypi.com/software/operating-systems/) or [Beagle Bone OS](https://docs.beagleboard.org/boards/beaglebone/blue/flashing-firmware.html)?

Well, the thing is that these OSes are built for a general user base. As a result, they contain extra redundant software packages for all kinds of users, such as a built-in IDE and a music player, that are probably not required for your specific commercial applications. Therefore, they take up extra resources, for example, CPU, RAM, and storage, which could have been used by your own business applications, and for that, removing them and their related library dependencies by hand is an _arduous_ task.

> By the way, using a built-in IDE like [_Thonny_](https://thonny.org/) on Raspberry Pi OS to develop production code is slow and inefficient; It should only be used for educational purposes.

Despite not being suitable for commercial applications, using an off-the-shelf OS is quite simple. You just flash the OS image to an SD card that is larger than the image itself using a tool like [_balenaEtcher_](https://etcher.balena.io/). After flashing the image, insert the SD card into the board, set it to **SD Card Boot Mode** (_this step may vary depending on your board; consult your board's technical user manual for instructions_), and boot it. That's it!

> Some vendors might even provide a script to copy the image from the SD card to the on-board eMMC (Embedded Multi-Media Card) flash memory, allowing you to remove the SD card later if you wish, since your board can now boot from the eMMC.

But what if you want to boot the image from a different medium, or even over a network connection? Off-the-shelf bootloaders are not designed for this purpose, and it is practically difficult to customize them to your advantage.

_Why, then, would we want to boot the OS (kernel) image from a different channel when we can just use the SD card?_

The answer is that a typical development setup for an SBC should allow developers to modify the kernel and root file system and flash them to the board's storage device as quickly as possible. It would be quite painful to move the SD card between your host PC and the target board every time you modify something.

### Typical Development Workflow

Similar to most embedded systems, most SBCs provide a [JTAG](https://www.xjtag.com/about-jtag/what-is-jtag/) interface which you can use to debug/flash programs and even upload a bootloader directly to the RAM in some cases (see [Falcon Mode from U-Boot](https://docs.u-boot.org/en/latest/develop/falcon.html), for e.g). However, there is a good chance that you probably won't need it most of the time, unless you are developing your own bootloader or kernel. In most cases, developers utilize on-board USB ports, or Ethernet for this purpose.

> TIP: A developer should be knowledgeable about how many media a specific board has that can be used to boot the OS image.

For example, with the Beagle Bone Black, you can use either the _Ethernet_ connection or the _USB_ client configured for ["Ethernet over USB"](https://en.wikipedia.org/wiki/Ethernet_over_USB) to load the `kernel image` and `rootfs` over a local IP network using [TFTP](https://en.wikipedia.org/wiki/Trivial_File_Transfer_Protocol) (Trivial File Transfer Protocol) and [NFS](https://en.wikipedia.org/wiki/Network_File_System) (Network File System).

![Beagle Bone Black](/images/bbb.png "Image taken from the technical reference manual")

Then, you can use the `Debug Serial Header` on the Beagle Bone Black, which exposes a UART interface that allows you to monitor console logs generated by both the bootloader and the kernel. A UART-to-TTL logic converter would be required to connect your host PC to it (see [this](https://www.adafruit.com/product/954) for example).

_The serial header pin-out on the Beagle Bone Black_:

| Pin No. | Signal        |
| ------- | ------------- |
| 1       | Ground        |
| 4       | Rx (Receive)  |
| 5       | Tx (Transmit) |

![Beagle Bone Black](/images/bbb-2.png "Image taken from the technical reference manual")

Suppose you have decided to use the Ethernet for flashing the kernel and UART for monitoring the logs or interacting with the board. _What's next?_

#### Bootloader

Understanding how the bootloader works and the boot sequence for your specific SBC is really important. The bootloader’s main job is to get board-specific device drivers and memory controllers (like DDR RAM, eMMC, SD Card, etc.) up and running before it loads the kernel. You can actually tell the bootloader where to load the kernel from; maybe from eMMC during production, or over an Ethernet connection during the development stage.

The **Beagle Bone Black** needs two stage bootloader designs. For example, when you compile the `u-boot` bootloader for this board, two binaries, named `MLO` and `u-boot.img`, would be generated.

> There are plenty of other bootloaders out there, but I don’t want to sound smart by listing names I’ve never actually used. If you ask me why I chose `u-boot`, it’s simply because I’m familiar with it and have seen it used in a lot of other projects.

`MLO` is a Secondary Program Loader (`SPL`) that’s first loaded by the 'ROM' code, the Primary Program Loader, which is hard-coded inside the SoC during manufacturing and can’t be modified by third parties. The size of `MLO` is intentionally kept smaller than the on-chip memory, which is **128 KB** (see Page 8 of the [datasheet](https://www.ti.com/lit/ds/symlink/am3358.pdf)), for example, in the `AM335x` SoC used by the Beagle Bone Black. That’s why the bootloader uses a two-stage design.

The full `u-boot` bootloader would barely fit in that tiny 128 KB, since the total binary size of board-specific device drivers and other components easily exceeds it. Thus, the job of `MLO` is to initialize the external RAM device (`512MB DDR3L`) which is larger than itself, and then, load the Tertiary Program Loader (TPL), `u-boot.img`, on it.

In short, the `ROM` code loads the `SPL`, then the `SPL` loads the `TPL`, and finally, the `TPL` loads the kernel itself. When the system starts up, the `ROM` code searches for the bootloader across all available media, according to the boot sequence set by the `SYSBOOT` configuration pins (see **Table 26-7** of the [datasheet](https://www.ti.com/lit/ug/spruh73q/spruh73q.pdf?ts=1762001206322&ref_url=https%253A%252F%252Fwww.google.com%252F)). It tries the first media in the sequence, and if it finds a bootloader, it loads it. If not, it moves on to the next media in the boot order, repeating this process until it either finds a bootloader or runs out of options.

There’s a `BOOT` switch on the BeagleBone Black that lets you change the boot media order. By default, when you power it on, it boots from the eMMC flash memory (denoted `MMC1`) first. If you press this switch before turning on the power, it will boot from the SD card (denoted `MMC0`) instead. This is handy during development, especially if you need to update the application-specific bootloader from the SD card.

## References

- Crosstool-NG - <https://crosstool-ng.github.io/docs/install/>
- U-Boot Documentation - <https://u-boot.org/>
- AM335x User Guide - <https://tha.de/~hhoegl/home/elinux/bbb/AM335x-U-Boot-User's-Guide.pdf>
- Beagle Bone Black Documentation - <https://docs.beagle.cc/boards/beaglebone/black/ch04.html>

```

```
